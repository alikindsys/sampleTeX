{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE TemplateHaskell #-}
{-# LANGUAGE DuplicateRecordFields #-}

module Compiler
  ( CompilationState (..),
    DocumentState (..),
    runCompileT,
    runCompile,
    texify,
    compileFile,
  )
where

import qualified Data.Map as M
import Data.Map (Map)

import qualified Data.Text as T

import Data.Functor.Identity (Identity (runIdentity))

import Control.Lens.TH (makeLenses)
import Control.Lens ((.~), (&))

import Control.Monad.IO.Class

import Control.Monad.Trans.Class (MonadTrans(lift))
import Control.Monad.Trans.State.Lazy (StateT , runStateT, get, put)
import Control.Monad.Trans.Except (ExceptT, runExceptT, throwE)

import System.FilePath ((</>), isAbsolute, makeValid, takeFileName, takeDirectory)
import System.Directory (makeAbsolute)

import Parser 
import Text.Megaparsec
import GHC.IO (unsafePerformIO)

data CompilationState = CompilationState
  { _file :: String,
    _pwd :: String,
    _kind :: PathKind
  }
  deriving (Show)

data DocumentState = DocumentState
  { _variableMap :: Map Identifier StringLiteral,
    _stack :: [String],
    _hasClass :: Bool,
    _initialized :: Bool,
    _compilation :: CompilationState
  }
  deriving (Show)

initialDoc =
  DocumentState
    { _variableMap = M.empty,
      _stack = [],
      _hasClass = False,
      _initialized = False,
      _compilation = CompilationState {_pwd = "", _file = "", _kind = SampleTex}
    }

makeLenses ''CompilationState
makeLenses ''DocumentState

-- | Custom StateT with support for error-handling
type CompileT e s m = StateT s (ExceptT e m)

type Compile e s = CompileT e s Identity

type CompileIO e s = CompileT e s IO

runCompileT :: (Monad m) => CompileT e s m a -> s -> m (Either e (a, s))
runCompileT m = runExceptT . runStateT m 

runCompile :: CompileT e s Identity a -> s -> Either e (a,s)
runCompile m = runIdentity . runCompileT m

compileFile :: CompileIO String CompilationState String
compileFile = do
  state <- get
  -- Very Naive Approach
  let path = (</>) <$> _pwd <*> _file $ state
  normalized <- liftIO $ makeAbsolute path
  str <- liftIO $ readFile normalized
  case _kind state of
    LaTeX -> pure $ "% Compilation Output from : " <> _file state <> "\n% Autogenerated by samplec\n" <> str <> "\n% End of compilation of : " <> _file state
    SampleTex -> compileIO path

-- | This requires an already transformed, canonical path to work.
compileIO :: String -> CompileIO String CompilationState String
compileIO path = do
  state <- get
  text <- liftIO $ T.pack <$> readFile path
  let awareDoc = initialDoc & compilation .~ state
  let compilation = runCompile (compile path text) awareDoc
  case compilation of
    Left err -> lift $ throwE err
    Right (x, _) -> pure $ "% Compilation Output from : " <> _file state <> "\n% Autogenerated by samplec\n" <> x <> "\n% End of compilation of : " <> _file state

-- | This requires an already transformed, canonical path to work.
compile :: String -> T.Text -> Compile String DocumentState String
compile path text = do
  state <- get
  case parse parseDocument path text of
    Left err ->
      lift . throwE $
        "[Parser Error] Failed while parsing : "
          <> path
          <> "\n"
          <> errorBundlePretty err
    Right objs -> do
      let compiled = runCompile (traverse texify objs) state
      case compiled of
        Left x ->
          lift . throwE $
            "[Compilation Error] Failed while compiling : " <> path <> "\n" <> x
        Right (tex, _) -> pure $ concatMap (<> "\n") tex

texify :: Object  -> Compile String DocumentState String

texify (StringLiteral' strlit) = pure $ text strlit

texify (CompoundString' compstr) = do
  x <- traverse texifyStringComponent $ components compstr
  pure $ concatMap ("\n" <>) x

texify (List' list) = texifyList list

texify (Variable' v) = do
  state <- get
  let ident = (identifier :: Variable -> Identifier) v
  let val = (value :: Variable -> StringLiteral) v
  let vmap = _variableMap state
  if M.member ident vmap
    then lift . throwE $ "Variable " <> toStr ident <> " was already defined."
    else put $ state & variableMap .~ M.insert ident val vmap
  pure ""

texify (VariableExport' (VariableExport [])) =
  lift . throwE $ "Attempted compiling an empty list"
texify (VariableExport' (VariableExport xs)) = do
  state <- get
  let _map = _variableMap state
  let kvps = map (\ident -> (,) ident $ M.member ident _map) xs
  let invalids = filter (not . snd) kvps
  if not . null $ invalids
    then
      lift . throwE $
        "The following variable(s) were never declared but tried exporting:"
          <> concatMap ((<>) "\n" . toStr . fst) invalids
    else pure $ concatMap tex $ M.toAscList _map
  where
    tex (ident, value) =
      "\\newcommand{\\" <> toStr ident <> "}{" <> text value <> "}\n"
    getVar _map key = _map M.! key

-- | Pragmas

texify (Pragma' Init) = do
  state <- get
  if _initialized state
    then
      lift . throwE $
        "Attempted initializing an already initialized document."
    else do
      put $ state & initialized .~ True & stack .~ "document" : _stack state
      pure "\\begin{document}\n"

texify (Pragma' (Begin k)) = do
  state <- get
  let func = toStr k
  let stk = _stack state
  let lowerCased = T.toLower (T.pack func)
  if lowerCased == "document" && _initialized state
    then lift . throwE $ "Duplicate Document Initialization."
    else
      if lowerCased == "document"
        then put $ state & stack .~ (toStr k : stk) & initialized .~ True
        else put $ state & stack .~ (toStr k : stk)
  pure $ "\\begin{" <> toStr k <> "}\n"

texify (Pragma' End) = do
  state <- get
  let stk = _stack state
  if null stk
    then
      lift . throwE $
        "Unescaped <End>. Please check if you have more <end>s then <begin>s."
    else do
      put $ state & stack .~ tail stk
      pure $ "\\end{" <> head stk <> "}\n"

texify (Pragma' (Section s)) = do
  pure $ "\\section{" <> s <> "}\n"

texify (Pragma' (NewPage)) = do
  pure $ "\\newpage{}\n"

texify (Pragma' (Import pack funcs)) = do
  pure $ "\\usepackage" <> funcStr <> "{" <> toStr pack <> "}\n"
  where
    funcStr =
      if null funcs
        then ""
        else "[" <> concatMap ((<>) "," . texifyFunctionKind) funcs <> "]"

texify (Pragma' (Class pack funcs)) = do
  state <- get
  if _hasClass state
    then lift . throwE $ "Duplicate Document Class."
    else put $ state & hasClass .~ True
  pure $ "\\documentclass" <> funcStr <> "{" <> toStr pack <> "}\n"
  where
    funcStr =
      if null funcs
        then ""
        else "[" <> concatMap ((<>) "," . texifyFunctionKind) funcs <> "]"

texify (Pragma' (Include path kind)) = do
  state <- get
  let current = _compilation state
  let newPath = transformPwd (_pwd current) path
  let (file, npath) = ((,) <$> takeFileName <*> takeDirectory) newPath
  let compilation =
        unsafePerformIO $
          runCompileT
            compileFile
            CompilationState {_pwd = npath, _file = file, _kind = kind}
  case compilation of
    Left s -> lift $ throwE s
    Right (x, _) -> pure x


texifyFunctionKind :: FunctionKind -> String
texifyFunctionKind (Setting k v) = toStr k <> "=" <> v
texifyFunctionKind (Function i) = toStr i
texifyFunctionKind (Value v) = v

texifyStringComponent ::  StringComponent -> Compile String DocumentState String
texifyStringComponent (EscapeSequence c) = pure [Parser.getChar c]
texifyStringComponent (Literal s) = pure s
texifyStringComponent (VariableReplacement (FString id)) = do
  state <- get
  let _map = _variableMap state
  let member = M.member id _map
  if member
    then pure . text $ _map M.! id
    else lift . throwE $ "The variable " <> toStr id <> " was not declared."

texifyList :: List -> Compile String DocumentState String
texifyList (List [] _ _) = lift $ throwE "Tried compiling an empty list."
texifyList (List xs Nothing False) = do
  items <- traverse texifyListItem xs
  let str = concatMap (<> "\n") items
  pure $ "\\begin{itemize}\n" <> str <> "\\end{itemize}"
texifyList (List xs Nothing True) = do
  items <- traverse texifyListItem xs
  let str = concatMap (<> "\n") items
  pure $ "\\begin{enumerate}\n" <> str <> "\\end{enumerate}"
texifyList (List xs (Just n) False) = do
  items <- traverse texifyListItem xs
  name <- texify $ CompoundString' n
  let str = concatMap (<> "\n") items
  pure $
    "\\begin{itemize}\n"
      <> "\\item[]{"
      <> name
      <> ":}\n"
      <> str
      <> "\\end{itemize}"
texifyList (List xs (Just n) True) = do
  items <- traverse texifyListItem xs
  name <- texify $ CompoundString' n
  let str = concatMap (<> "\n") items
  pure $
    "\\begin{enumerate}\n"
      <> "\\item[]{"
      <> name
      <> ":}\n"
      <> str
      <> "\\end{enumerate}"



texifyListItem :: ListItem -> Compile String DocumentState String
texifyListItem (StringLit (StringLiteral l)) = pure $ "\\item{" <> l <> "}\n"
texifyListItem (CompString v) = do
  s <- texify $ CompoundString' v
  pure $ "\\item{" <> s <> "}\n"
texifyListItem (InnerList l) = texifyList l

transformPwd :: FilePath -> FilePath -> FilePath
transformPwd current transformation =
  if isAbsolute transformation
    then transformation
    else makeValid $ current </> transformation
